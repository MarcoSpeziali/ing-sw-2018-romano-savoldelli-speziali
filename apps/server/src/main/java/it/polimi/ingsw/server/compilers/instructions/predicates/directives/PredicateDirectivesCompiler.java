package it.polimi.ingsw.server.compilers.instructions.predicates.directives;

import it.polimi.ingsw.core.actions.VariableSupplier;
import it.polimi.ingsw.server.compilers.commons.directives.ParameterDirective;
import it.polimi.ingsw.server.compilers.expressions.ConstantExpressionCaster;
import it.polimi.ingsw.core.instructions.predicates.Predicate;
import it.polimi.ingsw.server.Constants;
import it.polimi.ingsw.utils.io.XMLUtils;
import it.polimi.ingsw.utils.streams.StreamExceptionWrapper;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.io.Serializable;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class PredicateDirectivesCompiler {

    private PredicateDirectivesCompiler() {}

    /**
     * Compiles the directives to instantiate the predicates
     * @return a list of {@link PredicateDirective}
     * @throws IOException if any IO errors occur
     * @throws SAXException if any parse errors occur
     * @throws ParserConfigurationException if a DocumentBuilder
     *      cannot be created which satisfies the configuration requested.
     */
    public static List<PredicateDirective> compile() throws IOException, SAXException, ParserConfigurationException, ClassNotFoundException {
        return compile(Constants.Resources.PREDICATES_DIRECTIVES.getRelativePath(), true);
    }

    /**
     * Compiles the directives to instantiate the predicates
     * @param directivesPath the path to the directives
     * @return a list of {@link PredicateDirective}
     * @throws IOException if any IO errors occur
     * @throws SAXException if any parse errors occur
     * @throws ParserConfigurationException if a DocumentBuilder
     *      cannot be created which satisfies the configuration requested.
     */
    @SuppressWarnings("squid:S00112") // throw new RuntimeException(e)
    public static List<PredicateDirective> compile(String directivesPath, boolean isResource) throws ParserConfigurationException, SAXException, IOException, ClassNotFoundException {
        // retrieves the raw directives map
        Map<String, Object>[] rawDirectives = getRawDirectives(directivesPath, isResource);

        try {
            // then the map gets "mapped" (sorry for the word pun) into the actual predicateDirective list
            return Arrays.stream(rawDirectives)
                    .map(rawDirective -> {
                        // due to the strict (and terrible, imo) exception handling of java
                        // the possible exception generated by processPredicateDirective
                        // cannot be easily propagated
                        try {
                            // processes the predicate directive
                            return processPredicateDirective(rawDirective);
                        } catch (ClassNotFoundException e) {
                            return StreamExceptionWrapper.wrap(e);
                        }
                    }).collect(Collectors.toList());
        }
        catch (StreamExceptionWrapper e) {
            return e.tryFinalUnwrap(ClassNotFoundException.class);
        }
    }

    @SuppressWarnings("squid:S00112") // throw new RuntimeException(e)
    private static PredicateDirective processPredicateDirective(Map<String,Object> rawDirective)  throws ClassNotFoundException {
        // retrieves the id of the predicate
        String id = (String) rawDirective.get(PredicateDirectivesNodes.PREDICATE_DIRECTIVES_ID);

        // retrieves the class of the predicate
        String predicateClass = (String) rawDirective.get(PredicateDirectivesNodes.PREDICATE_DIRECTIVES_CLASS);

        // processes the raw parameters directives and maps them to the actual class
        List<ParameterDirective> parametersDirectives;
        try {
            parametersDirectives =
                    Arrays.stream(getRawParametersDirectives(rawDirective))
                            .map(d -> {
                                // due to the strict (and terrible, imo) exception handling of java
                                // the possible exception generated by processPredicateParameterDirective
                                // cannot be easily propagated
                                try {
                                    return processPredicateParameterDirective(d);
                                } catch (ClassNotFoundException e) {
                                    return StreamExceptionWrapper.wrap(e);
                                }
                            }).collect(Collectors.toList());
        }
        catch (StreamExceptionWrapper e) {
            return e.tryFinalUnwrap(ClassNotFoundException.class);
        }

        // finally creates and returns the predicate directive
        //noinspection unchecked
        return new PredicateDirective(
                id,
                (Class<Predicate>) Class.forName(predicateClass),
                parametersDirectives
        );
    }

    /**
     * Processes the raw parameter directive.
     * @param rawDirective The raw parameter directive in form of a {@link Map}
     * @return The actual parameter directive as {@link ParameterDirective}
     * @throws ClassNotFoundException if the class of the parameter does not exists
     */
    private static ParameterDirective processPredicateParameterDirective(Map<String, Object> rawDirective) throws ClassNotFoundException {
        // retrieves the class of the parameter
        String classType = (String) rawDirective.get(PredicateDirectivesNodes.PREDICATE_DIRECTIVES_PARAMETER_CLASS);

        // retrieves the position of the parameter (default 0)
        String stringPosition = (String) rawDirective.get(PredicateDirectivesNodes.PREDICATE_DIRECTIVES_PARAMETER_POSITION);
        int position = stringPosition == null ? 0 : Integer.parseInt(stringPosition);

        // retrieves the name of the parameter
        String name = (String) rawDirective.get(PredicateDirectivesNodes.PREDICATE_DIRECTIVES_PARAMETER_NAME);

        // retrieves the default value of the parameter
        String defaultValue = (String) rawDirective.get(PredicateDirectivesNodes.PREDICATE_DIRECTIVES_PARAMETER_DEFAULT_VALUE);

        // retrieves the multiplicity of the parameter
        boolean isMultiple = Boolean.parseBoolean(
                (String) rawDirective.get(PredicateDirectivesNodes.PREDICATE_DIRECTIVES_PARAMETER_IS_MULTIPLE)
        );

        // gets if the parameter is a VariableSupplier
        boolean isSupplied = Boolean.parseBoolean(
                (String) rawDirective.get(PredicateDirectivesNodes.PREDICATE_DIRECTIVES_PARAMETER_IS_SUPPLIED)
        );

        // creates the parameter directive
        return new ParameterDirective(
                isSupplied ? VariableSupplier.class : getClassFromName(classType, isMultiple),
                position,
                name,
                defaultValue == null ? null : (Serializable) ConstantExpressionCaster.cast(defaultValue),
                isMultiple
        );
    }

    /**
     * Reads the file and parses the xml in it into a {@link Map}.
     * @param path The path to the file, or the resource name
     * @param isResource {@code true} if the path points to a resource, {@code false} otherwise
     * @return The parsed xml as {@link Map}
     * @throws IOException If any IO errors occur
     * @throws SAXException If any parse errors occur
     * @throws ParserConfigurationException if a DocumentBuilder
     *      cannot be created which satisfies the configuration requested.
     */
    private static Map<String, Object>[] getRawDirectives(String path, boolean isResource) throws IOException, SAXException, ParserConfigurationException {
        Node node;

        // if the path is relative to the resources folder then the class loader must be provided
        if (isResource) {
            node = XMLUtils.parseXmlFromResource(path, PredicateDirectivesCompiler.class.getClassLoader());
        }
        else {
            node = XMLUtils.parseXml(path);
        }

        // the document
        Map<String, Object> document = XMLUtils.xmlToMap(node);

        if (document.containsKey(PredicateDirectivesNodes.PREDICATE_DIRECTIVES)) {
            // the children of predicates-directives (predicate-directives)
            return XMLUtils.getMapArrayAnyway(document, PredicateDirectivesNodes.PREDICATE_DIRECTIVES);
        }

        //noinspection unchecked
        return new Map[0];
    }

    /**
     * Retrieves the parameters directives from the provided predicate directives.
     * @param predicateDirectives the current predicate directives
     * @return the parameters directives from the provided predicate directives
     */
    private static Map<String, Object>[] getRawParametersDirectives(Map<String, Object> predicateDirectives) {
        Map<String, Object> parameters = XMLUtils.getMap(
                predicateDirectives,
                PredicateDirectivesNodes.PREDICATE_DIRECTIVES_PARAMETERS
        );

        return XMLUtils.getMapArrayAnyway(parameters, PredicateDirectivesNodes.PREDICATE_DIRECTIVES_PARAMETER);
    }

    /**
     * @param className the original class name
     * @param isMultiple if the class represents an array
     * @return the array version of the provided class
     */
    @SuppressWarnings("unchecked")
    private static Class<? extends Serializable> getClassFromName(String className, boolean isMultiple) throws ClassNotFoundException {
        if (isMultiple) {
            return (Class<? extends Serializable>) Class.forName("[L" + className + ";");
        }

        return (Class<? extends Serializable>) Class.forName(className);
    }

    /**
     * Holds the constants used while accessing the xml nodes and attributes.
     */
    private final class PredicateDirectivesNodes {
        static final String PREDICATE_DIRECTIVES = "predicate-directives";
        static final String PREDICATE_DIRECTIVES_ID = "@id";
        static final String PREDICATE_DIRECTIVES_CLASS = "@class";
        static final String PREDICATE_DIRECTIVES_PARAMETERS = "parameters-directives";
        static final String PREDICATE_DIRECTIVES_PARAMETER = "parameter-directives";
        static final String PREDICATE_DIRECTIVES_PARAMETER_CLASS = "@class";
        static final String PREDICATE_DIRECTIVES_PARAMETER_POSITION = "@position";
        static final String PREDICATE_DIRECTIVES_PARAMETER_NAME = "@name";
        static final String PREDICATE_DIRECTIVES_PARAMETER_DEFAULT_VALUE = "@default";
        static final String PREDICATE_DIRECTIVES_PARAMETER_IS_MULTIPLE = "@multiple";
        static final String PREDICATE_DIRECTIVES_PARAMETER_IS_SUPPLIED = "@supplied";

        private PredicateDirectivesNodes() { }
    }
}
