package it.polimi.ingsw.server.initializers;

import it.polimi.ingsw.server.Effect;
import it.polimi.ingsw.server.actions.ActionGroup;
import it.polimi.ingsw.server.actions.ExecutableAction;
import it.polimi.ingsw.server.compilers.actions.CompiledAction;
import it.polimi.ingsw.server.compilers.actions.CompiledActionGroup;
import it.polimi.ingsw.server.compilers.actions.CompiledExecutableAction;
import it.polimi.ingsw.server.compilers.effects.CompiledEffect;
import it.polimi.ingsw.utils.streams.StreamExceptionWrapper;

import java.lang.reflect.InvocationTargetException;
import java.util.List;
import java.util.stream.Collectors;

public class EffectInitializer {

    private EffectInitializer() {}

    /**
     * @param compiledEffect the {@link CompiledEffect} to instantiate
     * @return an instance of {@link Effect}
     * @throws NoSuchMethodException if the constructor could not be found
     * @throws IllegalAccessException if this {@code Constructor} object
     *         is enforcing Java language access control and the underlying
     *         constructor is inaccessible
     * @throws InstantiationException if the class that declares the
     *         underlying constructor represents an abstract class
     * @throws InvocationTargetException if the underlying constructor
     *         throws an exception
     */
    public static Effect instantiate(CompiledEffect compiledEffect) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        return new Effect(
                compiledEffect.getDescription(),
                compiledEffect.getEvaluableConstraint(),
                instantiateActions(compiledEffect.getCompiledExecutableActions()),
                compiledEffect.getInitialCost()
        );
    }

    /**
     * Instantiate a {@link List} of {@link CompiledExecutableAction}s.
     * @param executableActions the {@link List} of {@link CompiledExecutableAction}s
     * @return a {@link List} of {@link ExecutableAction}s
     * @throws NoSuchMethodException if the constructor could not be found
     * @throws IllegalAccessException if this {@code Constructor} object
     *         is enforcing Java language access control and the underlying
     *         constructor is inaccessible
     * @throws InstantiationException if the class that declares the
     *         underlying constructor represents an abstract class
     * @throws InvocationTargetException if the underlying constructor
     *         throws an exception
     */
    private static List<ExecutableAction> instantiateActions(List<CompiledExecutableAction> executableActions) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {
        try {
            return executableActions.stream()
                    .map(compiledExecutableAction -> {
                        // due to the strict (and terrible, imo) exception handling of java
                        // the possible exceptions generated by ActionGroupInitializer::instantiate
                        // and ActionInitializer::instantiate cannot be easily propagated
                        try {
                            if (compiledExecutableAction.getClassToInstantiate().equals(ActionGroup.class)) {
                                return ActionGroupInitializer.instantiate((CompiledActionGroup) compiledExecutableAction);
                            }
                            else {
                                return ActionInitializer.instantiate((CompiledAction) compiledExecutableAction);
                            }
                        } catch (NoSuchMethodException | InstantiationException | InvocationTargetException | IllegalAccessException e) {
                            return StreamExceptionWrapper.wrap(e);
                        }
                    }).collect(Collectors.toList());
        }
        catch (StreamExceptionWrapper e) {
            return e.tryUnwrap(NoSuchMethodException.class)
                    .tryUnwrap(InstantiationException.class)
                    .tryUnwrap(InvocationTargetException.class)
                    .tryFinalUnwrap(IllegalAccessException.class);
        }
    }
}
